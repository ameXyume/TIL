# C++の命令コンパイラー
C++コンパイラーを実行する命令はコンパイラーとOSにより変わるが、最も一般的に使われるC++の命令コンパイラーとしては、GNUコンパイラーとVisual Studioコンパイラーがある。

# GNUコンパイラー
基本的にGNUコンパイラーを実行する命令はg++(GNU C++ Compiler)である。\
因みにGNUでは、gccでもC++をコンパイルすることが出来る、gccは元々C言語用のコンパイラーで、GNU C Compilerの略語だったが、今はPascalやAdaなどの言語を支援することにより、GNU Compiler Comllectionに名前が変わっている。GCCに関してはまた今度勉強することにする。

では下の例文を見よう。

`$ g++ -o example example.cc`

「$」はシステムプロンプト、「-o example」はコンパイラーに伝達する引数、「example.cc」はc++のソースコードが入っているファイル名で、exampleという名前の実行ファイルを作成する命令である。\
ここで、OSによって実行ファイルの拡張子名も変わって来て、Windowsではexample.exe、Unixではexampleの名前で作られる。

「-o ファイル名」は引数だと説明したが、その通り、「-o ファイル名」の代わりに他の引数を入れることで他の命令を実行することができる。その例を下に記録する。

## 結果物生成
引数を追加することで、コンパイラーが実行ファイル以外にも中間段階を設定して、結果物を出すことができる。
>* -E : 前処理(Pre-Processing)過程まで終わらせて(コンパイルを遂行せずに)結果物を保存。
>* -S : コンパイル過程まで終わらせて(アセンブラーを遂行せずに)結果物を保存。
>* -c : アセンブリー過程までだけ終わらせて(リンカーを遂行せずに)結果物を保存。
>* -o <ファイル名> : <ファイル名>を持つ結果物を作成する。

```
$ g++ -E example.cc
// example.ccソースコードを前処理過程まで遂行する
$ g++ -E example.cc -o example.i
// example.ccソースコードを前処理過程まで遂行して、examplel.iに保存する。

$ g++ -S example.cc
// example.ccソースコードをコンパイル過程まで遂行する
$ g++ -S example.cc -o example.s    
// example.ccソースコードをコンパイル過程まで遂行して、examplel.sに保存する。

$ g++ -c example.cc
// example.ccソースコードをアセンブリー過程まで遂行する
$ g++ -c example.cc -o example.o
// example.ccソースコードをアセンブリー過程まで遂行して、examplel.iに保存する。
```
##  -v
gccでは-vがバージョンの情報などを担当していることに比べ、g++での-vはネット上の情報によると、g++では、コンパイル過程や、コンパイラーから生成されたプログラムを出力させるとなっているが、g++の動作を確認しているcygwin64にgccを一緒に入れているせいか、まるでgcc -vを使っているようにバージョンの情報を示している。ただ\
`$ g++ -v example.cc -o example.txt`\
で命令を作成すると、リンカーを遂行していないような状態で保存されていた。\
この引数に関してはもう少し調べる必要がありそうだ。