# 기본 입출력과 버퍼의 관계
std::endl이 줄바꿈을 함과 동시에 버퍼를 비운다 라는 설명은 많지만,\
std::cout에 대한 설명은 없어, 버퍼에 대한 이해가 없었을 때에는 cout과 버퍼가 어떠한 관계를 가지는지 이해할 수 없었다.\
이에, 본 문서에서는 기본 입출력과, 버퍼의 관계에 대해 설명 할 것이다.

# 버퍼란?
버퍼란, 처리 속도가 굉장히 빠른 CPU와 처리 속도가 느린 보조 기억 장치(특히 HDD) 사이에서 그 흠을 메꾸기 위해, 보조 기억 장치보다 빠른 주 기억 장치(RAM)의 영역을 가져와(단 주 기억 장치도 CPU의 캐쉬 메모리에 비해서는 느리다.), 버퍼 메모리를 설정하여 버퍼 메모리에 데이터를 축적시킨 후 쌓인 데이터를 한 번에 처리하기 위한 것이다.

# 입출력의 방식
일반적으로 입출력은 입출력할 내용을 버퍼에 쌓은 뒤, 버퍼를 비움으로써 한 번에 처리하는 경우가 많다.\
왜냐하면, 출력 연산(버퍼를 비우는 flushing)은 비싸기에, **빈번히 사용하게 될 경우 성능 저하**를 일으키기 때문이다.

# 그래서 cout이 버퍼랑 무슨 관계인데?
여기까지의 내용을 종합하면 추측될 수도 있겠지만, std::cout은 결국 **버퍼에 출력할 내용을 작성하는 것**이다.\
일반적으로 접하기 쉬운 프로그래밍 환경에서는
```cpp
#include <iostream>

int main(){
    std::cout << "Hello World!!!";
}
```
만 하더라도, 출력을 하기때문에 버퍼를 비우지도 않았는데 출력이 되었다고 생각하여, 버퍼와 cout의 관계를 이해하지 못할 수 있다.\
여기에는 몇 가지 이유가 있는데, 필자가 생각하는 직접적인 이유의 이전에, 몇가지 버퍼를 비우는 상황의 예시를 들어보겠다.
1. 프로그램을 정상적으로 마쳤을 때. main 함수에서 return을 실행하는 과정에서 모든 출력 버퍼를 비운다.
   * 물론, return 0;를 직접 명시적으로 작성하지 않고 암시적으로 작성되었을 경우도 마찬가지이다.
2. 버퍼가 가득 찼을 때, 다음 값을 기록하기 전에 버퍼를 비우게 된다.
3. std::endl, std::flush, std::ends와 같은 조작자를 사용해 명시적으로 버퍼를 비웠을 때.
4. unitbuf 조작자를 이용하였을 때.
5. 출력 스트림을 다른 스트림과 묶어 사용해, 묶은 스트림을 읽거나, 쓸 때.

단, 여기서 주의해야 할 점이 버퍼를 비우는 타이밍은 implementation defined이기 때문에, **시스템이나 컴파일러 등 개발환경에 따라 달라질 수 있다.**
* implementation defined란?
    * 구현 방법에 따라 정의된 행동과 비슷한 의미
    * 간단히, 시스템에 따라 다르다 라는 의미로 생각하면 된다.

버퍼가 가득차면 비워주는지, 아니면 그 전에 비워주는지 조차 implementation defined고, cout의 flush는 기준에 의한 엄격한 규칙이 없다.
<pre>
<a href = "https://stackoverflow.com/questions/22345226/when-does-cout-flush"><b>There is no strict rule by the standard</b> </a>
- Stack Overflow -
</pre>
그러므로, 명시적으로 flushing을 해주는 것 외에는 정해진 규칙은 없고, 시스템의 조건에 맞춰서 일어난다고 생각하는 편이 좋다.

## 그래서 니가 생각하는 직접적인 이유가 뭔데?
내가 생각하는 직접적인 이유는, cout의 dtor(소멸자)에 의한 것이다.\
정확히는, dtor 내에 flushing을 해주는 함수가 들어있을 것이라 추측된다.
* dtor = Destructor 소멸자
    * 흔히 보는 Book::~Book 같은거 맞음

cout의 dtor이 빨리 호출되어 출력이 바로 일어나는 것 처럼 보이는게 아닐까 생각중. 아마 들어가 있는 모습은
``` cpp
std::~cout(){
    //flushing 함수
}
```
와 같은 느낌으로 되어있을듯?

# 선배로 부터의 조언
버퍼를 작성한 후, 바로 버퍼를 비우는 것은 OS 등의 실행 환경에 따라 달라지는데, 비교적으로 Linux는 cout의 후에 바로 비우는 경향이 있고, Window의 경우는 cout 후에도 버퍼를 비우지 않는 경우가 있는 것 같다.\
그러므로 **실행 환경에 따라 프로그램 동작이 변하지 않게 하기 위해서**는 cout의 뒤에 endl 혹은 flush등을 기입 해 주는 것이 좋을 **수도** 있다.

## 견해
flushing이 비싸기는 하지만, 실행 환경에 따른 차이를 최소화 하기 위해서는 일리가 있는 소리일 수도 있지않을까?\
하지만, 빈번한 출력 연산이 성능을 저하시키는 것은 저명한 사실이기에, 되도록이면 반드시 필요한 경우가 아닌 이상 출력 기능을 제외시키고, 실행 중 로그와 같이 중요도가 떨어지는 출력의 경우 출력을 할지 안 할지를 간단히 변경 가능토록 하는 것도 좋은 방법이 될 것 같다.